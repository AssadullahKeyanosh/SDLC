Functional testing:
focuses on the functionality of the software, verifying that it meets the specified requirements and behaves as expected in different scenarios. This type of testing includes tests such as unit tests, integration tests, and acceptance tests, which validate the software's features, inputs, outputs, and interactions with other systems.

Non-functional testing, on the other hand, focuses on the non-functional aspects of software quality, such as performance, reliability, security, usability, and compatibility. This type of testing includes tests such as load testing, stress testing, security testing, and performance testing, which evaluate the software's ability to handle large amounts of data, traffic, and transactions, as well as its response time, resource consumption, and resilience under various conditions.
---------------------------------------------------------------------------------------------------------------------------------------------------------------------


Unit Testing: 
focuses on individual units of code, such as functions or methods, to ensure they are working correctly.

Integration Testing:
verifies that different units of code work correctly together when integrated.

Functional Testing:
checks if the software meets the requirements and specifications and performs the intended functions.

System Testing:
examines the overall behavior and performance of the software as a whole.

User Acceptance Testing (UAT):
Tests the software from the end-user perspective to validate that it meets their needs and expectations.

Regression Testing:
verifies that changes or updates to the software do not affect existing functionality.

Security Testing:
assesses the software's vulnerabilities and risks to ensure the security of sensitive information and data.

Performance Testing:
evaluates the software's performance, scalability, and speed under various conditions.

Usability Testing:
determines the ease of use, user-friendliness, and user satisfaction of the software.

Smoke Testing: 
Tests the software's critical functionality to ensure that it is working properly before moving on to more comprehensive testing.

Sanity Testing: 
Tests a small subset of the software to ensure that it is working as expected before moving on to more comprehensive testing.

Compatibility Testing: 
Tests the software's compatibility with different operating systems, browsers, and hardware

White Box Testing:
focuses on the internal logic and structure of the code.

Black Box Testing:
focuses on the functionality of the software and verifies it without any knowledge of its internal workings.



